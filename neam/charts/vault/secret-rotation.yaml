# Secret Rotation Policies and Automation
# This file contains configurations for automated secret rotation

# 1. Vault Secret Rotation Configuration
# =======================================

# Enable KV secrets engine version 2 (supports automatic rotation)
vault secrets enable -path=secret -version=2 kv

# Configure automatic rotation for database credentials
vault write secret/roles/database-rotation \
  rotate_period="720h"  # 30 days

# PostgreSQL Dynamic Credentials
vault write database/config/postgresql-rotation \
  plugin_name="postgresql-database-plugin" \
  allowed_roles="app-db-role" \
  connection_url="postgresql://{{username}}:{{password}}@neam-prod-postgresql-primary.production:5432/neam_production?sslmode=require" \
  username="vault_admin" \
  password="vault_admin_password" \
  rotation_statements="ALTER USER \"{{name}}\" WITH PASSWORD '{{password}}';"

# Create role for dynamic database credentials
vault write database/roles/app-db-role \
  db_name="postgresql-rotation" \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT neam_app TO \"{{name}}\";" \
  revocation_statements="DROP USER IF EXISTS \"{{name}}\";" \
  default_ttl="1h" \
  max_ttl="24h"

# 2. Kubernetes CronJob for Secret Rotation
# ==========================================

# Example CronJob for rotating application secrets
apiVersion: batch/v1
kind: CronJob
metadata:
  name: neam-secret-rotation
  namespace: neam-platform
  labels:
    app.kubernetes.io/name: neam-platform
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: neam-platform
spec:
  schedule: "0 2 * * 0"  # Weekly on Sunday at 2 AM
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app.kubernetes.io/name: neam-secret-rotation
        spec:
          serviceAccountName: neam-secret-rotation-sa
          containers:
          - name: rotation
            image: vault:1.13
            command:
            - /bin/sh
            - -c
            - |
              # Login to Vault using Kubernetes auth
              vault login -method=kubernetes role=neam-production
              
              # Generate new secrets
              NEW_JWT_SECRET=$(openssl rand -base64 32)
              NEW_ENCRYPTION_KEY=$(openssl rand -base64 32)
              
              # Update secrets in Vault
              vault kv put secret/production/application \
                jwt_secret="$NEW_JWT_SECRET" \
                encryption_key="$NEW_ENCRYPTION_KEY"
              
              # Trigger pod reload (if using CSI driver with refresh)
              # This will cause pods to receive new secrets
              kubectl rollout restart deployment/neam-sensing -n neam-platform
              kubectl rollout restart deployment/neam-intelligence -n neam-platform
            env:
            - name: VAULT_ADDR
              value: "https://vault.neam.io:8200"
            - name: VAULT_CACERT
              value: "/certs/vault/ca.crt"
            volumeMounts:
            - name: vault-tls
              mountPath: /certs/vault
              readOnly: true
          volumes:
          - name: vault-tls
            secret:
              secretName: vault-tls
          restartPolicy: OnFailure

# 3. Database Credential Rotation Script
# =======================================

#!/bin/bash
# rotate_db_credentials.sh - Rotate database credentials with zero downtime

set -e

# Configuration
ENVIRONMENT=${1:-production}
NAMESPACE="neam-${ENVIRONMENT}"
VAULT_ADDR="${VAULT_ADDR:-https://vault.neam.io:8200}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Login to Vault
vault_login() {
    log_info "Logging into Vault..."
    vault login -method=kubernetes role=neam-${ENVIRONMENT} > /dev/null
}

# Get current credentials
get_current_credentials() {
    log_info "Retrieving current credentials..."
    vault kv get -field=connection_string secret/${ENVIRONMENT}/database/postgresql
}

# Generate new credentials
generate_new_credentials() {
    log_info "Generating new credentials..."
    NEW_PASSWORD=$(openssl rand -base64 32)
    echo $NEW_PASSWORD
}

# Update Vault with new credentials
update_vault_secret() {
    local new_password=$1
    log_info "Updating Vault secret..."
    vault kv put secret/${ENVIRONMENT}/database/postgresql \
      username="neam_${ENVIRONMENT}" \
      password="${new_password}" \
      connection_string="postgresql://neam_${ENVIRONMENT}:${new_password}@neam-prod-${ENVIRONMENT}-postgresql-primary.${ENVIRONMENT}:5432/neam_${ENVIRONMENT}?sslmode=require"
}

# Update database with new password
update_database_password() {
    local new_password=$1
    log_info "Updating database password..."
    
    # Get admin credentials from Vault
    local admin_password=$(vault kv get -field=password secret/${ENVIRONMENT}/database/postgresql-admin)
    
    # Update password using psql
    PGPASSWORD="${admin_password}" psql -h neam-prod-${ENVIRONMENT}-postgresql-primary.${ENVIRONMENT} \
      -U neam_${ENVIRONMENT}_admin -d neam_${ENVIRONMENT} \
      -c "ALTER USER neam_${ENVIRONMENT} WITH PASSWORD '${new_password}';"
}

# Trigger application restart
trigger_restart() {
    log_info "Triggering application restart..."
    
    local deployments=$(kubectl get deployment -n ${NAMESPACE} -o jsonpath='{.items[*].metadata.name}')
    
    for deployment in $deployments; do
        log_info "Restarting ${deployment}..."
        kubectl rollout restart deployment/${deployment} -n ${NAMESPACE}
        
        # Wait for rollout to complete
        kubectl rollout status deployment/${deployment} -n ${NAMESPACE} --timeout=10m
    done
}

# Verify rotation
verify_rotation() {
    log_info "Verifying secret rotation..."
    
    # Check that pods are running
    kubectl wait --for=condition=Ready pods --all -n ${NAMESPACE} --timeout=5m
    
    # Check application health
    local pods=$(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/part-of=neam-platform -o jsonpath='{.items[*].metadata.name}')
    
    for pod in $pods; do
        local status=$(kubectl get pod ${pod} -n ${NAMESPACE} -o jsonpath='{.status.phase}')
        if [ "$status" != "Running" ]; then
            log_error "Pod ${pod} is not running (status: ${status})"
            return 1
        fi
    done
    
    log_info "Secret rotation verified successfully"
}

# Main rotation process
main() {
    log_info "Starting database credential rotation for ${ENVIRONMENT}..."
    
    vault_login
    
    local new_password=$(generate_new_credentials)
    
    update_vault_secret "${new_password}"
    
    update_database_password "${new_password}"
    
    trigger_restart
    
    verify_rotation
    
    log_info "Database credential rotation completed successfully"
}

main

# 4. Secret Rotation Schedule
# ============================

# Rotate database credentials weekly
# 0 3 * * 0 /scripts/rotate_db_credentials.sh production

# Rotate application secrets monthly
# 0 4 1 * * /scripts/rotate_application_secrets.sh production

# Rotate Kafka credentials quarterly
# 0 5 1 */3 * /scripts/rotate_kafka_credentials.sh production

# 5. Emergency Secret Rotation
# =============================

# In case of security incident, immediately rotate all secrets
# This script rotates all secrets immediately

#!/bin/bash
# emergency_rotation.sh - Emergency secret rotation for all environments

EMERGENCY_MODE=true
ENVIRONMENT=${1:-production}

echo "EMERGENCY SECRET ROTATION - ${ENVIRONMENT}"
echo "============================================"
echo "This will immediately rotate all secrets for ${ENVIRONMENT}"
read -p "Are you sure you want to continue? (yes/no): " confirm

if [ "${confirm}" != "yes" ]; then
    echo "Aborted."
    exit 1
fi

# Rotate all database passwords
./rotate_db_credentials.sh ${ENVIRONMENT}

# Rotate Kafka credentials
./rotate_kafka_credentials.sh ${ENVIRONMENT}

# Rotate application secrets
./rotate_application_secrets.sh ${ENVIRONMENT}

# Notify security team
curl -X POST -H 'Content-type: application/json' \
  --data '{"text":"ðŸš¨ EMERGENCY: All secrets have been rotated for '${ENVIRONMENT}' environment"}' \
  $SLACK_WEBHOOK_URL

echo "Emergency rotation complete. Review all logs and monitor for anomalies."
